<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Building a UI component library for a product | Ananthu Kanive</title>
<meta name="keywords" content="">
<meta name="description" content="Building a component library is a very important milestone in a products life-cycle. It usually isn’t the first thing anyone talks about in the early stages of a product. Startups usually don’t even hire designers, they give that responsibility to front end or mobile developers to come up with a clean user interface owing to the fact that they might have worked with designers in the past and have picked up on some of the UI/UX knowledge.">
<meta name="author" content="">
<link rel="canonical" href="https://lonelycpp.github.io/2020/05/11/building-component-library/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lonelycpp.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lonelycpp.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lonelycpp.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lonelycpp.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lonelycpp.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script type="application/javascript">
var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
var doNotTrack = (dnt == "1" || dnt == "yes");
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-165995640-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script><meta property="og:title" content="Building a UI component library for a product" />
<meta property="og:description" content="Building a component library is a very important milestone in a products life-cycle. It usually isn’t the first thing anyone talks about in the early stages of a product. Startups usually don’t even hire designers, they give that responsibility to front end or mobile developers to come up with a clean user interface owing to the fact that they might have worked with designers in the past and have picked up on some of the UI/UX knowledge." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lonelycpp.github.io/2020/05/11/building-component-library/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-05-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-05-11T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Building a UI component library for a product"/>
<meta name="twitter:description" content="Building a component library is a very important milestone in a products life-cycle. It usually isn’t the first thing anyone talks about in the early stages of a product. Startups usually don’t even hire designers, they give that responsibility to front end or mobile developers to come up with a clean user interface owing to the fact that they might have worked with designers in the past and have picked up on some of the UI/UX knowledge."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://lonelycpp.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Building a UI component library for a product",
      "item": "https://lonelycpp.github.io/2020/05/11/building-component-library/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Building a UI component library for a product",
  "name": "Building a UI component library for a product",
  "description": "Building a component library is a very important milestone in a products life-cycle. It usually isn’t the first thing anyone talks about in the early stages of a product. Startups usually don’t even hire designers, they give that responsibility to front end or mobile developers to come up with a clean user interface owing to the fact that they might have worked with designers in the past and have picked up on some of the UI/UX knowledge.",
  "keywords": [
    
  ],
  "articleBody": "Building a component library is a very important milestone in a products life-cycle. It usually isn’t the first thing anyone talks about in the early stages of a product. Startups usually don’t even hire designers, they give that responsibility to front end or mobile developers to come up with a clean user interface owing to the fact that they might have worked with designers in the past and have picked up on some of the UI/UX knowledge.\nDevelopers usually aren’t keen on building radically different user interfaces, rather they like to go with the “standard”. There are a ton of tooling and open source support for popular design guidelines like the material design. Every platform has a material design theme to it. It’s everywhere. VS Code, websites, mobile apps, and everything that developers build in their free time.\nSo it’s easy to jump on the open source component library, or CSS framework bandwagon only to realize that the end product looks exactly like a ton of other generic apps out there. In startups, they usually don’t follow any of these popular design guidelines to make the product stand out. BOOM - spaghetti UI code. Divs with weird css, components with custom styles and injected styles. Everything is now coded as a minion.\nWhen a company grows, it quickly realizes that its UI is a mess. When the devs are afraid to open a file, you know something’s seriously wrong. Time to build a custom component library.\nHere are a few guidelines that I follow when building component libraries or new components in general.\nHave A Plan Before making a component library, plan it out. Don’t hastily jump into it. Think about what components are already in the product. What is not consistent? What could have been a shared element? Make a list of some very commonly used components that needs to be standardized throughout the product. (eg - A Primary Button)\nAn important point would be to think of all the items that will definitely not be used. The product has no plans on supporting multiple themes, ever? Don’t build a theme system. The product doesn’t want to show loaders inside buttons? Don’t build loading buttons. Period.\nInvolve the Design Team There’s a good chance that the UI/UX team has a component library of their own. Involve them in the process and come up with a plan on how a component library must be built. There is no point in making a UI component library without involving the design team. The components will be used not only by the devs to make building features faster, but need to be used by the designers to design features with existing components.\nMake Style Immutable with UI states When making a component library for a specific product, there is more clarity on how elements need to look. The product will have a set of theme colors that needs to be used across the board. The component itself will have complete control over its appearance. The parent component will have no control over how the component is styled whatsoever.\nIn react / react native, the style prop is used to define the styles of a component. A custom component is usually designed to take a prop called containerStyles (or something similar) that overrides the component’s default style. When the parent wants a component that has a non-standard color, just pass in a containerStyle object, right? Wrong! Non standard components should not be allowed. This should be avoided at all costs. It will only lead to spaghetti code.\nInstead, the components just need to take in states or modes. The appearance of the component is determined by the component based on this state. For example, a button can have a state called type which can be primary or secondary. What this means is that the parent is asking for a “primary button” and does not care about how it looks. The button component itself will have all the styles required for the states.\nAny extra additions in the future needs to be treated as a design decision and can be easily accommodated later as the style is completely controlled by the component. Just another style state to account for.\nData and testability UI components shouldn’t really worry about data. It should only accept final forms of data. Data manipulation should be done elsewhere and not in the component. Components should focus on displaying data exactly as it is given to them.\nThis makes writing tests a lot simpler, to a point where a snapshot test will be enough in most cases. Any extra complications can be trivially included when compared to something decentralized like only using components provided by the framework, in place. This will lead to a certain peace of mind, in knowing that someday one little change will not screw up the whole product.\nUI Documentation Documenting UI components are better done visually. Storybook is a great example of an awesome UI documentation tool. Create a system where anyone can see how a component looks like in isolation. Make a catalogue of different combinations of UI states that a component can appear in. Storybook has “knobs” that can dynamically change UI states, controlled by whoever is reading the documentation.\nA component library that is implemented properly will be easy to use, easy to maintain and much easier to teach; given the whole thing is visually documented. The outcome of this whole process should be focused on the benefits it can offer in the future. It makes the whole product feel more mature and familiar. A robust component library can cut down UI development time of new features or redesigns by a significant margin. It can help identify patterns that don’t match the product as a whole.\n",
  "wordCount" : "963",
  "inLanguage": "en",
  "datePublished": "2020-05-11T00:00:00Z",
  "dateModified": "2020-05-11T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lonelycpp.github.io/2020/05/11/building-component-library/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ananthu Kanive",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lonelycpp.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lonelycpp.github.io/" accesskey="h" title="Ananthu Kanive (Alt + H)">Ananthu Kanive</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://github.com/LonelyCpp" title="Projects">
                    <span>Projects</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://linkedin.com/in/ananthu-kanive-18376b61/" title="Contact">
                    <span>Contact</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Building a UI component library for a product
    </h1>
    <div class="post-meta"><span title='2020-05-11 00:00:00 +0000 UTC'>Mon, May 11, 2020</span>

</div>
  </header> 
  <div class="post-content"><p>Building a component library is a very important milestone in a products life-cycle. It usually isn’t the first thing anyone talks about in the early stages of a product. Startups usually don’t even hire designers, they give that responsibility to front end or mobile developers to come up with a clean user interface owing to the fact that they might have worked with designers in the past and have picked up on some of the UI/UX knowledge.</p>
<p>Developers usually aren’t keen on building radically different user interfaces, rather they like to go with the “standard”. There are a ton of tooling and open source support for popular design guidelines like the material design. Every platform has a material design theme to it. It&rsquo;s everywhere. VS Code, websites, mobile apps, and everything that developers build in their free time.</p>
<p>So it&rsquo;s easy to jump on the open source component library, or CSS framework bandwagon only to realize that the end product looks exactly like a ton of other generic apps out there. In startups, they usually don&rsquo;t follow any of these popular design guidelines to make the product stand out. <em><strong>BOOM</strong></em> - spaghetti UI code. Divs with weird css, components with custom styles and injected styles. Everything is now coded as a minion.</p>
<p>When a company grows, it quickly realizes that its UI is a mess. When the devs are afraid to open a file, you know something’s seriously wrong. Time to build a custom component library.</p>
<p>Here are a few guidelines that I follow when building component libraries or new components in general.</p>
<h2 id="have-a-plan">Have A Plan<a hidden class="anchor" aria-hidden="true" href="#have-a-plan">#</a></h2>
<p>Before making a component library, plan it out. Don’t hastily jump into it. Think about what components are already in the product. What is not consistent? What could have been a shared element? Make a list of some very commonly used components that needs to be standardized throughout the product. (eg - A Primary Button)</p>
<p>An important point would be to think of all the items that will definitely not be used. The product has no plans on supporting multiple themes, ever? Don&rsquo;t build a theme system. The product doesn&rsquo;t want to show loaders inside buttons? Don&rsquo;t build loading buttons. Period.</p>
<h2 id="involve-the-design-team">Involve the Design Team<a hidden class="anchor" aria-hidden="true" href="#involve-the-design-team">#</a></h2>
<p>There’s a good chance that the UI/UX team has a component library of their own. Involve them in the process and come up with a plan on how a component library must be built. There is no point in making a UI component library without involving the design team. The components will be used not only by the devs to make building features faster, but need to be used by the designers to design features with existing components.</p>
<h2 id="make-style-immutable-with-ui-states">Make Style Immutable with UI states<a hidden class="anchor" aria-hidden="true" href="#make-style-immutable-with-ui-states">#</a></h2>
<p>When making a component library for a specific product, there is more clarity on how elements need to look. The product will have a set of theme colors that needs to be used across the board. The component itself will have complete control over its appearance. The parent component will have no control over how the component is styled whatsoever.</p>
<p>In react / react native, the <code>style</code> prop is used to define the styles of a component. A custom component is usually designed to take a prop called <code>containerStyles</code> (or something similar) that overrides the component&rsquo;s default style. When the parent wants a component that has a non-standard color, just pass in a containerStyle object, right? Wrong! Non standard components should not be allowed. This should be avoided at all costs. It will only lead to spaghetti code.</p>
<p>Instead, the components just need to take in states or modes. The appearance of the component is determined by the component based on this state. For example, a button can have a state called <code>type</code> which can be primary or secondary. What this means is that the parent is asking for a “primary button” and does not care about how it looks. The button component itself will have all the styles required for the states.</p>
<figure>
    <img loading="lazy" src="/cmp_lib/ui_states.png"/> 
</figure>

<p>Any extra additions in the future needs to be treated as a design decision and can be easily accommodated later as the style is completely controlled by the component. Just another style state to account for.</p>
<h2 id="data-and-testability">Data and testability<a hidden class="anchor" aria-hidden="true" href="#data-and-testability">#</a></h2>
<p>UI components shouldn’t really worry about data. It should only accept final forms of data. Data manipulation should be done elsewhere and not in the component. Components should focus on displaying data exactly as it is given to them.</p>
<p>This makes writing tests a lot simpler, to a point where a snapshot test will be enough in most cases. Any extra complications can be trivially included when compared to something decentralized like only using components provided by the framework, in place. This will lead to a certain peace of mind, in knowing that someday one little change will not screw up the whole product.</p>
<h2 id="ui-documentation">UI Documentation<a hidden class="anchor" aria-hidden="true" href="#ui-documentation">#</a></h2>
<p>Documenting UI components are better done visually. Storybook is a great example of an awesome UI documentation tool. Create a system where anyone can see how a component looks like in isolation. Make a catalogue of different combinations of UI states that a component can appear in. Storybook has “knobs” that can dynamically change UI states, controlled by whoever is reading the documentation.</p>
<figure>
    <img loading="lazy" src="/cmp_lib/chip.png"/> 
</figure>

<p>A component library that is implemented properly will be easy to use, easy to maintain and much easier to teach; given the whole thing is visually documented. The outcome of this whole process should be focused on the benefits it can offer in the future. It makes the whole product feel more mature and familiar. A robust component library can cut down UI development time of new features or redesigns by a significant margin. It can help identify patterns that don&rsquo;t match the product as a whole.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>Ananthu P Kanive</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
